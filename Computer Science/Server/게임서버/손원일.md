# 게임서버
스터디 일시 : 24.06.07

### 게임 서버, 클라이언트
&nbsp;게임의 기본적인 로직은 사용자의 입력에 따른 게임 규칙에 맞게 처리 처리 후 재 렌더링을 하게 됩니다.<br/>
&nbsp;싱글 플레이의 경우( 스토리 진행 게임, 탄막 슈팅게임 등등 ) 네트워크를 통해서 서버와의 통신이 굳이 필요하지 않기 때문에 클라이언트 부분에서 입력, 규칙에 맞는 로직, 렌더링 부분을 구현하고 처리하게 됩니다.<br/>
&nbsp;멀티 플레이의 경우( FPS, MMORPG 등등 ) 네트워크를 통해 서버에 사용자의 입력을 전달하고 규칙에 맞는 로직을 처리 후 서버에서 클라이언트에게 결과(응답)을 전송하고 응답에 맞는 처리를 클라이언트 측에서 처리를 해야합니다.

### 게임 서버와 웹 서버의 차이
&nbsp;웹 서버 즉, HTTP 서버는 대체로 Stateless 서버로 클라이언트가 요청을 보낼때 요청에 맞게 응답을 하는 서버이며, Request와 Response 형태로 데이터를 주고 받게 되며 Stateless이기 때문에 요청과 응답을 주고 받으면 서버에서는 더이상 클라이언트의 상태를 저장해두고 있지 않게됩니다.<br/>
![웹서버](https://github.com/user-attachments/assets/780d7ce8-dc9b-489a-b42e-2655a6effcf0)<br/>
&nbsp;그러나, 게임 서버는 클라이언트의 요청을 보내지 않아도 서버측에서 클라이언트로 데이터를 전송해야하는 상황이 있다는 차이점이 존재하기 때문에 Stateful 서버이며, 클라이언트가 서버에 패킷을 전송해도 서버는 응답을 보내지 않아도 되며 요청하지 않았을 경우에도 서버에서 클라이언트로 패킷을 전송할 수 있어야합니다.<br/>
![게임서버](https://github.com/user-attachments/assets/fc335283-fd87-4f3f-b236-63dfe70ce954)<br/>
&nbsp;FPS, MMORPG와 같은 여러 플레이어가 동일한 공간( 맵 )에 위치하여 오브젝트와 상호작용하여 이 정보를 모두에게 공유해야할 때 실시간 통신이 중요하며, 이를 위해 서버 측에서는 최소한의 로직을 처리해야합니다.<br/>
![image](https://github.com/user-attachments/assets/eb067a39-4f17-475a-9f0d-ca0c5622554d)<br/>
&nbsp;그러나 SNG(Social Network Game) 장르[소셜 네트워크 서비스 플랫폼 기반으로 사용자 온라인 인맥을 활용하여 서로 경쟁하는 게임 ex) 클래시 오브 클랜, 쿠키런 킹덤]은 상대의 맵의 정보만 얻어올 수 있다면 실시간으로 정보를 공유하지 않아도 되기 때문에 이러한 종류의 장르는 웹서버와 동일하게 Stateless 서버를 사용하여도 무관합니다.<br/>
![image](https://github.com/user-attachments/assets/7543b759-603f-42e4-a7bb-4a144dc64260)<br/>

&rarr; 점점 게임 컨텐츠가 다양해 지면서 Stateful만, Stateless만 사용하는 형식이 아닌 두가지 방식이 함께 적용되어 사용되고 있습니다
ex) 
- 비동기 온라인게임 (Stateless) + 실시간 채팅(Stateful)
- 비동기 온라인게임 (Stateless) + 실시간 pvp(Stateful)
- 실시간 온라인게임 (Stateful) + 랭킹 시스템 (Stateless)
등등..

&nbsp;그리고, 클라이언트도 마찬가지로 서버에 요청을하고 응답이 왔을 때 해당응답에 대한 렌더링이 꼭 이루어질 필요는 없으며, 요청을 하지 않았을 때에도 서버에서 온 패킷에 대하여 렌더링이 필요한 경우도 있다.

### 게임서버 최적화
&nbsp;실시간 통신이 필요로하는 멀티 게임환경에서 사용자의 입력에 따른 전체 처리 로직을 서버가 전담하여 처리하는 방식이 아닌 클라이언트에서 처리할 수 있는 부분은 클라이언트에서 처리를 하고 다른 사용자 혹은 게임 자체에 영향을 미칠 수 있는 처리는 서버에게 요청하여 처리를 하는 방식으로 로직을 분담하여 처리함으로 서버의 부담을 줄여 실시간 통신의 성능을 높히는 방식을 사용합니다.

RPG를 예를 들어 본다면 플레이어 **A,B,C** 가 몬스터 **α**를 레이드하고 있는 상황에서<br/> 
&nbsp;<U>각 플레이어들의 스킬 쿨타임 계산, 애니메이션 실행 여부(모션, 이펙트 표현)등</U>은 플레이어의 로컬 pc 즉 클라이언트 측에서 처리를 하는것이 실시간 통신의 성능을 향상 시킬 수 있을 것이고,<br/>
&nbsp;<U>플레이어의 HP, MP, 위치, 스킬 사용 여부 정보, 몬스터에 가해진 데미지에 따른 몬스터의 체력 변동 사항 등</U> 게임의 전반적인 규칙과 관련된 내용은 서버에게 전송하여 서버가 해당 정보를 필요로하는 사용자에게 데이터를 전송하게끔하여야합니다.

*- 추가 공부사항 비동기 I/O 매커니즘*


### 서버 아키텍쳐 패턴
1. 실시간 멀티플레이어 게임서버
    &nbsp;플레이어간 상호 작용이 필요한 게임에서 사용, 플레이어간 통신, 게임 상태 동기화, 충돌 감지 및 해결과 같은 실시간 요소를 처리
2. 클라이언트-서버 모델
    &nbsp;대부분 온라인 게임의 모델로 클라이언트는 UI와 그래픽을 처리하고 서버는 게임 로직, 플레이어 상태 및 보안을 담당하게 됩니다.
3. Peer To Peer 모델
    &nbsp;플레이어간 직접 통신이 이루어지는 방식으로 작은 규모의 멀티 게임이나 특수 환경에서 효과적일 수 있다.
4. 게임 클라우드 서시스
    &nbsp;대규모 다중 플레이어 게임에 적합한 모델로 클라우드 서비스 제공업체의 리소스를 사용하여 서버를 동적으로 확장할 수 있다.
    ex) Amazon GameLift, Microsoft Azure PlayFab, Google Cloud Game Servers 등
5. 게임 데이터베이스 서버
    &nbsp;게임에서는 플레이어의 진행상황, 아이템 정보, 랭킹등 데이터를 저장하는 데이터베이스 서버도 중요

### 게임서버의 종류
- 전용서버(Dedicate Server) :
&nbsp; 호스트가 방을 생성하고, 클라이언트가 방에 접속하여서 게임을 진행하는 방식으로 개인(클라이언트) 컴퓨터는 쾌적하게 플레이할 수 있지만, 서버 연산이 많아지면 고정 비용이 발생합니다.<br/>
![전용서버](https://github.com/user-attachments/assets/a1f9dfce-dce3-4a97-b36b-4486ca9a2e05)<br/>
- 릴레이 서버(Relay 서버)
&nbsp;릴레이 서버는 플레이어간의 직접적인 통신을 중개하고 중계하는 역할을 합니다 P2P 모델이 어려운 상황에서 사용 될 수 있다.
    - 플레이어간의 직접 연결이 방화벽과 같은 이유로 어려울 때 중계 서버를 사용하여 통신을 원할 하게 합니다
    - 보안 및 중립적인 중개 역할을 수행하기 때문에 클라이언트 간에 직접 연결할 필요가 없어진다.
- 리슨서버(Listen Server or Play as Host) :
&nbsp; 플레이어 중 한명이 서버의 역할을 대신하여 참가하는 방식으로 개인의 컴퓨터 중 하나가 서버의 역할을 해주기에 서비스 유지 비용은 적게 들고, 물리적을 가까운 사람들끼리 한다면 속도가 전용 서버보다 빠를 수 있다.
&nbsp; 단 호스트의 기기 성능에 따라 품질이 달라 질 수 있고, 호스트가 게임 종료시 참여하고 있는 클라이언트 중 한 명을 호스트로 선정하는 절차가 필요합니다.
<br/>
![리슨서버](https://github.com/user-attachments/assets/70cec83f-0336-488d-b37e-5d9a1b9e28e7)<br/>
-P2P(Peer to Peer)
&nbsp; 게임에 참가한 "모두"가 호스트 역할을 하고 클라이언트들이 서로 직접 연결되어 클라이언트가 직접 연산하고 값을 클라이언트 들에게 전파하는 방식이다, 리슨서버와의 차이점은 한 명이 게임을 나가도 호스트를 새로 선정할 필요가 없다.
&nbsp; 서로가 연결되어 있기에 참가자가 많아지면 연산이 늘어나 게임의 품질이 떨어질 수 있어 통상적으로 16명을 넘기지 않는 환경의 게임에서 사용됩니다.<br/>
![P2P서버](https://github.com/user-attachments/assets/fad8e427-3170-43a1-956f-05077eae09eb)
</br>


- 매치메이킹 서버(전용 서버를 주로 사용)
&nbsp;어떤 서버방식을 사용하더라도 결국 참가할 클라이언트들이 서로를 찾아 방에 모이는 과정에서 사용할 전용서버가 별도로 필요합니다 이러한 서버를 매치메이킹 서버라고 하고, MMORPG 게임은 대부분 전용 서버로 처리하며, 주로 레이드, 데스매치를 진행하는 종류의 게임에서 매치 메이킹은 전용 서버를 사용하지만, 방이 형성되고 라운드를 시작할 때에는 플레이어 중 한명을 호스트로 삼는 리슨 서버 방식을 많이 사용합니다.

&rarr; 클라이언트가 하는 일이 많을 수록 보안에 취약해진다. 웹사이트에 f12로 명시되는 변수가 많은 웹게임이 보안에 취약한 것과 비슷한 이유이고, 
&nbsp;P2P 방식이 보안에 가장 취약하다는 단점이 있고, 그 다음으로는 리슨서버 한 명이 서버를 자처하기에 취약할 수 밖에 없다. 전용서버를 구동하는것이 보안상에 비교적 안전할 수 밖에 없다.

### Unity에서 지원하는 게임서버
- Photon
    - 네트워크 종합 솔루션으로 멀티 게임에 필요한 클라우드 서버나 웹서비스 등을 제공하는 네트워크 엔진<br/>
    - 장점 :
        1. 개발 참고 자료가 잘 되어 있다 (API 문서, 튜토리얼)
        2. 서버와 클라이언트 로직을 분리하지 않아도 됩니다( 클라이언트만 구현하면 멀티플레이가 가능 )
        3. 개발 속도가 빨라짐
        4. 별도 서버 호스팅을 하지 않아도 pun2 제품 자체에 클라우드 서버, 스케일링, 게임 룸, 매칭 등을 지원
    - 단점 :
        1. Relay Server 로직을 사용하기 때문에 지정된 클라이언트가 게임서버 데이터를 게임룸의 다른 플레이어게 전송하기 때문에 보안에 취약합니다
        2. 사실상 게임 로직을 전부 클라이언트에서 처리하기 때문에 네트워크가 좋지 않은 플레이어가 있다면 경우에 따라 게임 진행이 원할하지 못할 수 있습니다.
        3. 전용 서버를 사용할 수 없다. 리슨 형식이기 때문에 마스터 클라이언트(호스트 역할)이 연결이 끊기게 되면 게임에 문제가 생기게 되거나 새로운 호스트 역할을 선정하는 로직이 필요합니다. 
<br/>
 ![image](https://github.com/user-attachments/assets/0cad2d8a-396f-4340-8225-188d165fbfc8)<br/>
- Mirror
    - 기존의 Unity에서 제공하던 Unet에서 fork해서 오픈 소스로 참여하고 제작한 라이브러리입니다.
    - 특징
        - **HighLevelAPI**이기 때문에 서버 엔진단의 작동 방식을 몰라도 API를 잘 활용하면 멀티플레이 구현이 가능합니다
        - TCP 베이스로 탄생했으나 게임에 맞는 다른 Transport를 사용할 때 최적화가 가능합니다.(빠른 페이스 게임의 겨웅 TCP보다 UDP가 적절=> **low level Transport 적용 가능**)
        - **Server/Client의 서버 모델을 지원한다**. 게임의 핵심 로직을 담당하는 전용 서버와 UI와 그래픽을 담당하는 클라이언트로 구현이 가능하다. 추가로 리슨 서버 방식도 지원합니다.
        - Unity는 기본적으로 MonoBehaviour를 상속받아 사용하지만 **NetworkBehaviour라는 상위 오브젝트를 상속받고 구현**됩니다.
        - 오픈소스 라이브러리에 커뮤니티가 잘 구축 되어있습니다.
        - API문서(단, 영어)와 튜터리얼이 잘 구축되어있습니다.
-Mirage
    - Mirror에서 fork되어 새롭게 제작 중인 라이브러리입니다.
    - 특징
        - 오픈소스 라이브러리입니다.
        - Mirro와 달리 UDP 기반입니다.
        - fast domain reload를 지원합니다. (조사가 조금 더 필요합니다)
        - 세부적인 기능들이 모듈화가 잘 되어있습니다.
        - UPM(Unity Package Manager)를 통해 업데이트가 되어서 업데이트마다 쉽게 받아서 적용이 가능하다
        - 최적화가 잘되어 있어서 서버가 CPU와 메모리 사용량을 적게 먹습니다.
        - 같은 프로세스 내부에 다수의 클라이언트 + 다수 서버를 구현할 수 있도록 지원합니다.
        - Error Handling을 자체적으로 지원합니다.
        - API 메뉴얼이 영어입니다.
        - 최근 개발이 진행되다보니 튜토리얼이 거의 없고 커뮤니티가 부족하고, 불안정하다는 단점이 있습니다.

### Unreal에서 지원하는 게임서버
&nbsp;Unreal은 자체 네트워크 라이브러리를 제공하며, 리슨서버, 전용서버 모델로 게임 구축이 가능하여 적절한 모델을 선택하고 리플리케이트 해야하는 플레이어 상태, 게임 상태를 지정하고 클라이언트에서만 처리할 로직, 서버에서 처리해야할 로직을 구분하여 게임을 제작하면 된다.<br/>
```Net/UnrealNetwork.h```

---
참고
<br/>
게임서버와 클라이언트 :<br/>
https://tech-interview.tistory.com/186
<br/>
게임서버와 웹서버의 차이 :<br/>
https://velog.io/@yarogono/%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84-%EC%9B%B9-%EC%84%9C%EB%B2%84%EC%99%80-%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84%EC%9D%98-%EC%B0%A8%EC%9D%B4
http://post.procademy.co.kr/archives/624
<br/>
게임서버의 종류 : <br/>
https://alpaca-code.tistory.com/58
https://nybot-house.tistory.com/85#google_vignette
https://velog.io/@metaldragon/%EA%B2%8C%EC%9E%84-%EC%84%9C%EB%B2%84-%EB%AA%A8%EB%8D%B8%EC%97%90-%EB%8C%80%ED%95%B4%EC%84%9C-%EC%95%8C%EC%95%84%EB%B3%B4%EC%9E%90
<br/>
Unity에서 지원하는 게임 서버 :<br/>
https://medium.com/wardgames/unity-%EB%A9%80%ED%8B%B0%ED%94%8C%EB%A0%88%EC%9D%B4-%EA%B2%8C%EC%9E%84%EC%9D%84-%EB%A7%8C%EB%93%A4%EA%B8%B0-%EC%9C%84%ED%95%9C-mirror-mirage-%EC%86%8C%EA%B0%9C-a74b58bc115f
<br/>
Photon :<br/>
https://doc.photonengine.com/ko-kr/server/current/getting-started/photon-server-intro#https://doc.photonengine.com/ko-kr/server/current/getting-started/photon-server-intro
